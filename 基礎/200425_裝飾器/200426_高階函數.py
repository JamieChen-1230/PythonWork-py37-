"""
裝飾器原則：
    一、不修改被修飾函數的原代碼
    二、不修改被修飾函數的調用方法
高階函數（滿足其一則為高階函數）：
    一、函數可以作為參數傳給另一個函數
    二、函數的返回值為另一個函數（若返回值為該函數本身，則為遞歸）
"""


# ----------------符合不修改原代碼(原則一)----------------
import time


def f1():
    time.sleep(1)
    print("running f1.")


def deco_1(func):  # 符合不修改被修飾函數的原代碼
    print(func)  # => <function f1 at 0x0000022C6A8C56A8>
    start = time.time()
    func()  # 調用f1()
    end = time.time()
    print("運行時間 -> %s" % (end-start))  # => 運行時間1.0005557537078857


deco_1(f1)  # f1的原調用方法是f1()，但現在卻是deco_1(f1)，所以不是裝飾器
print()


# ----------------符合原則一、二，但會多運行一次被調用函數 (這是高階函數的極限了)----------------
def f2():
    time.sleep(1)
    print("running f2.")


# 不修改原代碼且不修改調用方法
def deco_2(func):  # 符合不修改被修飾函數的原代碼
    start = time.time()
    func()  # 調用f2()
    end = time.time()
    print("運行時間%s" % (end-start))  # => 運行時間1.0005557537078857
    return func


f2 = deco_2(f2)
print("-----分隔線-----")
f2()  # 符合不修改被修飾函數的調用方法
# 但運行結果會多運行一次f2()，如下
# running f2.
# 運行時間1.0005519390106201
# -----分隔線-----
# running f2.

"""
結論：
    一、光只利用高階函數無法實現裝飾器。
        原因：裝飾器由【高階函數+函數嵌套+閉包】所組成
"""
