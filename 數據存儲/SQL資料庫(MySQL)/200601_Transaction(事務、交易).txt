事務：
    - 指邏輯上的一組操作，組成這組操作的各個單元，要不全部成功，要不全部不成功。
    - 事務必要性的經典例子：
        例子：
            假如一個銀行的數據庫有兩張表，支票表(checking)和儲蓄表(savings)，
            現在要從用戶Jane的支票賬戶轉移200美元到她的儲蓄賬戶，那麽至少需要三個步驟：
                一、檢查支票賬戶的余額高於或者等於200美元。
                二、從支票賬戶余額中減去200美元。
                三、在儲蓄帳戶余額中增加200美元。
                ※ 上述三個步驟的操作必須打包在一個事務中，任何一個步驟失敗，則必須回滾所有的步驟。
        程式指令：
            1. start transaction;
            2. select balance from checking where customer_id = 10233276;
            3. update checking set balance = balance - 200.00 where customer_id = 10233276;
            4. update savings set balance = balance + 200.00 where customer_id = 10233276;
            5. commit;
    - 事務標準特性，ACID：
        原子性(Atomicity)：
            - 一個事務被視為不可分割的「最小」工作單元，整個事務中的所有操作要麽全部提交成功，要麽全部失敗撤銷。
            - 對於一個事務來說，不可能只執行其中的一部分操作，這就是事務的原子性。
        一致性(consistency)：
            - 數據庫總是從一個一致性的狀態轉換到另一個一致性的狀態。(在沒有提交事務之前，數據庫不會被修改)
            - 在例子中，一致性確保即使在執行第三、四條語句之間時系統崩潰，支票賬戶中也不會損失200美元，因為事務最終沒有提交，所以事務中所做的修改也不會保存到數據庫中。
        隔離性(isolation)：
            - 通常來說，一個事務所做的修改在最終提交以前，對其他事務是不可見的。
            - 在例子中，當執行完第三條語句，第四條語句還未開始時，此時去查看支票帳戶的余額並沒有被減去200美元。(要等到commit結束才會改變)
        持久性(durability)：
            - 一旦事務提交，則其所做的修改則會永久保存到數據庫。
    - 隔離級別：
        READ UNCOMMITTED(未提交讀)：
            - 事務中的修改，即使沒有提交，對其他事務也都是可見的，事務可以讀取未提交的數據，這也被稱為髒讀（Dirty Read）。
            - 這個級別會導致很多問題，從性能上來說，不會比其他的級別好太多，但卻缺乏其他級別的很多好處，一般很少使用。
        READ COMMITTED(提交讀)：
            - 大多數數據庫系統的默認隔離級別都是READ COMMTTED(MySQL例外，是REPEATABLE READ)。
            - 一個事務開始時，只能看見「已提交」的事務所做的修改；也就是說一個事務從開始直到提交之前，所做的任何修改對其他事務都是不可見的。
            - 有不可重復讀（nonrepeatble read）問題，因為兩次執行同樣的查詢，可能會得到不一樣的結果。
        REPEATABLE READ(可重復讀)：
            - 解決了髒讀和不可重讀問題，該隔離級別保證了在同一個事務中多次讀取同樣記錄結果是一致的。
            - 但有可能會產生幻讀（Phantom Read）的問題。
                幻讀：當A事務在讀取記錄時(此時有2條數據)，B事務卻插入了新的記錄(此時有3條數據)，當A事務再次讀取該範圍的記錄時，
                      因為REPEATABLE READ會保持多次讀取一致性，所以就會產生明明數據庫中有3條數據，但事務中只能看到2條數據。
        SERIALIZABLE(可串行化)：
            - 為最高的隔離級別。
            - 它通過強制事務串行執行，避免了前面說的幻讀的問題。
                簡單來說，SERIALIZABLE會在讀取每一行數據都加鎖，所以可能導致大量的超時和鎖爭用問題。
            - 實際應用中也很少用到這個隔離級別，只有在非常需要確保數據的一致性而且可以接受沒有並發的情況下，才考慮采用該級別。
    - 操作指令：
        - start transaction： 開啟一個事務
        - Rollback： 撤銷事務，即撤銷指定的sql語句和修改(只能回退insert delete update語句)，回滾到上一次commit的位置
        - Commit： 提交事務，提交事務中指令修改的數據永久保存
        - savepoint： 保留點，事務處理中設置的臨時佔位符你可以對它發布回退(與整個事務回退不同)
